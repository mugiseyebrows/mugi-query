// DO NOT EDIT ** This file was generated by mugicpp ** DO NOT EDIT
#include "mugisql.h"
namespace mugisql {

#define DRIVER_MYSQL "QMYSQL"
#define DRIVER_SQLITE "QSQLITE"
#define DRIVER_ODBC "QODBC"
#define DRIVER_PSQL "QPSQL"

    QString inParenthesis(const QString& expr, bool yes) {
        return yes ? ("(" + expr + ")") : expr;
    }
    QString spaced(const QString& expr, bool yes) {
        return yes ? (" " + expr + " ") : expr;
    }

    fieldlist_t::fieldlist_t() {
    }
    fieldlist_t::fieldlist_t(const field_t& field) {
        this->append(&field);
    }
    fieldlist_t::fieldlist_t(const std::initializer_list<const field_t*>& values)
        : QList<const field_t*>(values) {
    }
    QString fieldlist_t::toString(bool full) const {
        QStringList res;
        foreach (const field_t* field, *this) { res << (full ? field->fullName() : field->name()); }
        return res.join(", ");
    }

    aliasedtable_t::aliasedtable_t() : mTable(0), mAlias(0) {
    }
    aliasedtable_t::aliasedtable_t(const table_t& table, const alias_t& alias)
        : mTable(&table), mAlias(&alias) {
    }
    aliasedtable_t::aliasedtable_t(const table_t& table) : mTable(&table), mAlias(0) {
    }
    QString aliasedtable_t::toString() const {
        if (!mTable) {
            return QString();
        }
        if (mAlias) {
            return QString("%1 %2").arg(mAlias->tableName()).arg(mAlias->aliasName());
        }
        return mTable->aliasName();
    }

    arg_t::arg_t() : mField(0) {
    }
    arg_t::arg_t(const field_t& field) : mField(&field) {
    }
    arg_t::arg_t(const QVariant& value) : mValue(value), mField(0) {
    }
    arg_t::~arg_t() {
    }
    QString arg_t::toString(QSqlDriver* driver, bool fullname) const {
        if (!mField) {
            QSqlField field(QString(), mValue.type());
            field.setValue(mValue);
            return driver->formatValue(field);
        }
        return fullname ? mField->aliasName() : mField->name();
    }
    const field_t* arg_t::field() const {
        return mField;
    }
    QVariant arg_t::value() const {
        return mValue;
    }

    expr_t::expr_t() : mType(expr_null) {
    }
    expr_t::expr_t(const field_t& field) : arg_t(field), mType(expr_leaf) {
    }
    expr_t::expr_t(int value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(const QDateTime& value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(const QString& value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(const char* value) : arg_t(QString(value)), mType(expr_leaf) {
    }
    expr_t::expr_t(const QVariant& value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(expr_type type, const QList<expr_t>& args) : mType(type), mArgs(args) {
    }
    bool expr_t::isNull() const {
        return mType == expr_null;
    }
    expr_t::expr_type expr_t::type() const {
        return mType;
    }
    QList<expr_t> expr_t::args() const {
        return mArgs;
    }
    expr_t expr_t::arg(int index) const {
        return mArgs[index];
    }
    QString expr_t::infix(QSqlDriver* driver, bool fullname, const QString& name) const {
        return joinArgs(driver, true, fullname, spaced(name));
    }
    QString expr_t::func(QSqlDriver* driver, bool fullname, const QString& name) const {
        return name + inParenthesis(joinArgs(driver, false, fullname, ", "));
    }
    QString expr_t::prefix(QSqlDriver* driver, bool fullname, const QString& name) const {
        return name + " " + joinArgs(driver, true, fullname, ", ");
    }
    QString expr_t::suffix(QSqlDriver* driver, bool fullname, const QString& name) const {
        return joinArgs(driver, true, fullname, ", ") + " " + name;
    }
    QString expr_t::toString(QSqlDriver* driver, bool fullname) const {
        static QMap<expr_type, QString> infixmap = {{expr_equal, "="},
                                                    {expr_not_equal, "<>"},
                                                    {expr_less, "<"},
                                                    {expr_more, ">"},
                                                    {expr_less_or_equal, "<="},
                                                    {expr_more_or_equal, ">="},
                                                    {expr_like, "LIKE"},
                                                    {expr_or_, "OR"},
                                                    {expr_and_, "AND"},
                                                    {expr_add, "+"},
                                                    {expr_sub, "-"},
                                                    {expr_mul, "*"},
                                                    {expr_div, "/"},
                                                    {expr_sqlite_mod, "%"}};
        static QMap<expr_type, QString> prefixmap = {{expr_not_, "NOT"},
                                                     {expr_distinct, "DISTINCT"}};
        static QMap<expr_type, QString> funcmap = {{expr_abs, "ABS"},
                                                   {expr_sum, "SUM"},
                                                   {expr_avg, "AVG"},
                                                   {expr_min, "MIN"},
                                                   {expr_max, "MAX"},
                                                   {expr_round, "ROUND"},
                                                   {expr_sqlite_datetime, "DATETIME"},
                                                   {expr_mysql_sign, "SIGN"},
                                                   {expr_mysql_floor, "FLOOR"},
                                                   {expr_mysql_ceil, "CEIL"},
                                                   {expr_mysql_sqrt, "SQRT"},
                                                   {expr_mysql_asin, "ASIN"},
                                                   {expr_mysql_acos, "ACOS"},
                                                   {expr_mysql_atan, "ATAN"},
                                                   {expr_mysql_sin, "SIN"},
                                                   {expr_mysql_cos, "COS"},
                                                   {expr_mysql_tan, "TAN"},
                                                   {expr_mysql_mod, "MOD"},
                                                   {expr_mysql_power, "POWER"}};
        static QMap<expr_type, QString> suffixmap = {{expr_is_null, "IS NULL"},
                                                     {expr_is_not_null, "IS NOT NULL"},
                                                     {expr_desc, "DESC"},
                                                     {expr_asc, "ASC"}};
        if (mType == expr_leaf) {
            return arg_t::toString(driver, fullname);
        } else if (mType == expr_count) {
            return "COUNT(*)";
        } else if (mType == expr_noescape) {
            return mArgs[0].value().toString();
        } else if (mType == expr_in) {
            return mArgs[0].toString(driver, fullname) + spaced("IN") +
                   inParenthesis(joinArgs(inArgs(mArgs.mid(1)), driver, false, fullname, ", "));
        } else if (mType == expr_as) {
            return mArgs[0].toString(driver, fullname) + spaced("AS") + mArgs[1].value().toString();
        } else if (mType == expr_between) {
            return mArgs[0].toString(driver, fullname) + spaced("BETWEEN") +
                   mArgs[1].toString(driver, fullname) + spaced("AND") +
                   mArgs[2].toString(driver, fullname);
        } else if (mType == expr_not_between) {
            return mArgs[0].toString(driver, fullname) + spaced("NOT BETWEEN") +
                   mArgs[1].toString(driver, fullname) + spaced("AND") +
                   mArgs[2].toString(driver, fullname);
        } else if (infixmap.contains(mType)) {
            return infix(driver, fullname, infixmap[mType]);
        } else if (prefixmap.contains(mType)) {
            return prefix(driver, fullname, prefixmap[mType]);
        } else if (suffixmap.contains(mType)) {
            return suffix(driver, fullname, suffixmap[mType]);
        } else if (funcmap.contains(mType)) {
            return func(driver, fullname, funcmap[mType]);
        }
        return QString();
    }
    exprlist_t expr_t::inArgs(const exprlist_t& args) const {
        if (args.size() == 1 && args[0].value().type() == QVariant::List) {
            QVariantList values = args[0].value().toList();
            exprlist_t res;
            foreach (const QVariant& value, values) { res << expr_t(value); }
            return res;
        }
        return args;
    }
    QString expr_t::joinArgs(QSqlDriver* driver, bool parenthesis, bool fullname,
                             const QString& glue) const {
        return joinArgs(mArgs, driver, parenthesis, fullname, glue);
    }
    QString expr_t::joinArgs(const exprlist_t& args, QSqlDriver* driver, bool parenthesis,
                             bool fullname, const QString& glue) const {
        QStringList res;
        static QSet<expr_type> noParenthesis = {
            expr_leaf,       expr_abs,         expr_sum,        expr_avg,
            expr_min,        expr_max,         expr_round,      expr_sqlite_datetime,
            expr_mysql_sign, expr_mysql_floor, expr_mysql_ceil, expr_mysql_sqrt,
            expr_mysql_asin, expr_mysql_acos,  expr_mysql_atan, expr_mysql_sin,
            expr_mysql_cos,  expr_mysql_tan,   expr_mysql_mod,  expr_mysql_power};
        foreach (const expr_t& arg, args) {
            res << inParenthesis(arg.toString(driver, fullname),
                                 parenthesis && !noParenthesis.contains(arg.type()));
        }
        return res.join(glue);
    }
    bool operator==(const expr_t& expr1, const expr_t& expr2) {
        return expr1.type() == expr2.type() && expr1.args() == expr2.args() &&
               expr1.value() == expr2.value() && expr1.field() == expr2.field();
    }

    exprlist_t::exprlist_t() {
    }
    exprlist_t::exprlist_t(const fieldlist_t& fields) {
        foreach (const field_t* field, fields) { append(*field); }
    }
    exprlist_t::exprlist_t(const QList<const field_t*>& fields) {
        foreach (const field_t* field, fields) { append(*field); }
    }
    exprlist_t::exprlist_t(const QList<expr_t>& fields) {
        append(fields);
    }
    exprlist_t::exprlist_t(const QVariantList& values) {
        append(expr_t(values));
    }
    exprlist_t::exprlist_t(const field_t& field) {
        append(field);
    }
    exprlist_t::exprlist_t(const expr_t& expr) {
        append(expr);
    }
    exprlist_t::exprlist_t(const std::initializer_list<expr_t>& values) : QList<expr_t>(values) {
    }
    QString exprlist_t::toString(QSqlDriver* driver, bool fullname) const {
        QStringList result;
        foreach (const expr_t& expr, *this) { result << expr.toString(driver, fullname); }
        return result.join(", ");
    }
    exprlist_t operator+(const exprlist_t& arg1, const exprlist_t& arg2) {
        exprlist_t res;
        res.append(arg1);
        res.append(arg2);
        return res;
    }
    exprlist_t operator+(const exprlist_t& arg1, const QVariant& arg2) {
        return arg1 + exprlist_t(expr_t(arg2));
    }
    exprlist_t operator+(const QVariant& arg1, const exprlist_t& arg2) {
        return exprlist_t(expr_t(arg1)) + arg2;
    }

    joinexpr_t::joinexpr_t() : mType(join_inner) {
    }
    joinexpr_t::joinexpr_t(join_type type, const expr_t& expr) : mExpr(expr), mType(type) {
    }
    QString joinexpr_t::toString(const aliasedtable_t& table, QSqlDriver* driver) const {
        static QStringList joins = {"INNER JOIN", "LEFT JOIN", "RIGHT JOIN"};
        return QString("%1 %2 ON %3")
            .arg(joins[mType])
            .arg(table.toString())
            .arg(mExpr.toString(driver));
    }

    limit_t::limit_t() : mOffset(0), mCount(0) {
    }
    limit_t::limit_t(int offset, int count) : mOffset(offset), mCount(count) {
    }
    limit_t::limit_t(int count) : mOffset(0), mCount(count) {
    }
    QString limit_t::toString() const {
        if (mCount == 0) {
            return QString();
        }
        if (mOffset == 0) {
            return QString("LIMIT %1").arg(mCount);
        }
        return QString("LIMIT %1, %2").arg(mOffset).arg(mCount);
    }

    expr_t count() {
        return expr_t(expr_t::expr_count, {});
    }
    expr_t noescape(const QString& arg) {
        return expr_t(expr_t::expr_noescape, {arg});
    }
    expr_t in(const expr_t& field, const exprlist_t& values) {
        return expr_t(expr_t::expr_in, field + values);
    }
    expr_t as(const expr_t& expr, const expr_t& alias) {
        return expr_t(expr_t::expr_as, {expr, alias});
    }
    expr_t between(const expr_t& expr, const expr_t& v1, const expr_t& v2) {
        return expr_t(expr_t::expr_between, {expr, v1, v2});
    }
    expr_t notBetween(const expr_t& expr, const expr_t& v1, const expr_t& v2) {
        return expr_t(expr_t::expr_not_between, {expr, v1, v2});
    }
    expr_t equal(const exprlist_t& args) {
        return expr_t(expr_t::expr_equal, args);
    }
    expr_t equal(const expr_t& arg0, const expr_t& arg1) {
        return equal({arg0, arg1});
    }
    expr_t notEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_not_equal, args);
    }
    expr_t notEqual(const expr_t& arg0, const expr_t& arg1) {
        return notEqual({arg0, arg1});
    }
    expr_t less(const exprlist_t& args) {
        return expr_t(expr_t::expr_less, args);
    }
    expr_t less(const expr_t& arg0, const expr_t& arg1) {
        return less({arg0, arg1});
    }
    expr_t more(const exprlist_t& args) {
        return expr_t(expr_t::expr_more, args);
    }
    expr_t more(const expr_t& arg0, const expr_t& arg1) {
        return more({arg0, arg1});
    }
    expr_t lessOrEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_less_or_equal, args);
    }
    expr_t lessOrEqual(const expr_t& arg0, const expr_t& arg1) {
        return lessOrEqual({arg0, arg1});
    }
    expr_t moreOrEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_more_or_equal, args);
    }
    expr_t moreOrEqual(const expr_t& arg0, const expr_t& arg1) {
        return moreOrEqual({arg0, arg1});
    }
    expr_t like(const exprlist_t& args) {
        return expr_t(expr_t::expr_like, args);
    }
    expr_t like(const expr_t& arg0, const expr_t& arg1) {
        return like({arg0, arg1});
    }
    expr_t or_(const exprlist_t& args) {
        return expr_t(expr_t::expr_or_, args);
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1) {
        return or_({arg0, arg1});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return or_({arg0, arg1, arg2});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return or_({arg0, arg1, arg2, arg3});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return or_({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t and_(const exprlist_t& args) {
        return expr_t(expr_t::expr_and_, args);
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1) {
        return and_({arg0, arg1});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return and_({arg0, arg1, arg2});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return and_({arg0, arg1, arg2, arg3});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
                const expr_t& arg4) {
        return and_({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t add(const exprlist_t& args) {
        return expr_t(expr_t::expr_add, args);
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1) {
        return add({arg0, arg1});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return add({arg0, arg1, arg2});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return add({arg0, arg1, arg2, arg3});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return add({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t sub(const exprlist_t& args) {
        return expr_t(expr_t::expr_sub, args);
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1) {
        return sub({arg0, arg1});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return sub({arg0, arg1, arg2});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return sub({arg0, arg1, arg2, arg3});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return sub({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t mul(const exprlist_t& args) {
        return expr_t(expr_t::expr_mul, args);
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1) {
        return mul({arg0, arg1});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return mul({arg0, arg1, arg2});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return mul({arg0, arg1, arg2, arg3});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return mul({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t div(const exprlist_t& args) {
        return expr_t(expr_t::expr_div, args);
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1) {
        return div({arg0, arg1});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return div({arg0, arg1, arg2});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return div({arg0, arg1, arg2, arg3});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return div({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t not_(const expr_t& arg) {
        return expr_t(expr_t::expr_not_, {arg});
    }
    expr_t distinct(const expr_t& arg) {
        return expr_t(expr_t::expr_distinct, {arg});
    }
    expr_t isNull(const expr_t& arg) {
        return expr_t(expr_t::expr_is_null, {arg});
    }
    expr_t isNotNull(const expr_t& arg) {
        return expr_t(expr_t::expr_is_not_null, {arg});
    }
    expr_t desc(const expr_t& arg) {
        return expr_t(expr_t::expr_desc, {arg});
    }
    expr_t asc(const expr_t& arg) {
        return expr_t(expr_t::expr_asc, {arg});
    }
    expr_t abs(const expr_t& arg) {
        return expr_t(expr_t::expr_abs, {arg});
    }
    expr_t sum(const expr_t& arg) {
        return expr_t(expr_t::expr_sum, {arg});
    }
    expr_t avg(const expr_t& arg) {
        return expr_t(expr_t::expr_avg, {arg});
    }
    expr_t min(const expr_t& arg) {
        return expr_t(expr_t::expr_min, {arg});
    }
    expr_t max(const expr_t& arg) {
        return expr_t(expr_t::expr_max, {arg});
    }
    expr_t round(const expr_t& arg) {
        return expr_t(expr_t::expr_round, {arg});
    }

    namespace sqlite {

        expr_t mod(const exprlist_t& args) {
            return expr_t(expr_t::expr_sqlite_mod, args);
        }
        expr_t mod(const expr_t& arg0, const expr_t& arg1) {
            return mod({arg0, arg1});
        }
        expr_t datetime(const exprlist_t& args) {
            return expr_t(expr_t::expr_sqlite_datetime, args);
        }
        expr_t datetime(const expr_t& arg0, const expr_t& arg1) {
            return datetime({arg0, arg1});
        }
    } // namespace sqlite

    namespace mysql {

        expr_t sign(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sign, {arg});
        }
        expr_t floor(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_floor, {arg});
        }
        expr_t ceil(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_ceil, {arg});
        }
        expr_t sqrt(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sqrt, {arg});
        }
        expr_t asin(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_asin, {arg});
        }
        expr_t acos(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_acos, {arg});
        }
        expr_t atan(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_atan, {arg});
        }
        expr_t sin(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sin, {arg});
        }
        expr_t cos(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_cos, {arg});
        }
        expr_t tan(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_tan, {arg});
        }
        expr_t mod(const exprlist_t& args) {
            return expr_t(expr_t::expr_mysql_mod, args);
        }
        expr_t mod(const expr_t& arg0, const expr_t& arg1) {
            return mod({arg0, arg1});
        }
        expr_t power(const exprlist_t& args) {
            return expr_t(expr_t::expr_mysql_power, args);
        }
        expr_t power(const expr_t& arg0, const expr_t& arg1) {
            return power({arg0, arg1});
        }
    } // namespace mysql

    query_t::query_t() : mDatabase(QSqlDatabase::database()) {
    }
    query_t::query_t(const QSqlDatabase& database) : mDatabase(database) {
    }
    QSqlQuery query_t::query() const {
        return mQuery;
    }
    bool query_t::exec() {
        mQuery = QSqlQuery(mDatabase);
        QString expr = toString();
        return mQuery.exec(expr);
    }
    QString query_t::joinNotEmpty(const QStringList& values, const QString& glue) {
        QStringList result;
        foreach (const QString& value, values) {
            if (!value.isEmpty()) {
                result << value;
            }
        }
        return result.join(glue);
    }
    QSqlError query_t::lastError() const {
        return mQuery.lastError();
    }
    QString query_t::lastQuery() const {
        return mQuery.lastQuery();
    }
    int query_t::numRowsAffected() const {
        return mQuery.numRowsAffected();
    }

    select_t::select_t(const exprlist_t& fields)
        : mFields(fields), mJoinType(joinexpr_t::join_inner) {
    }
    select_t::select_t(const QSqlDatabase& database, const exprlist_t& fields)
        : query_t(database), mFields(fields), mJoinType(joinexpr_t::join_inner) {
    }
    QVariant select_t::value(int index) const {
        return mQuery.value(index);
    }
    QVariant select_t::value(const expr_t& expr) {
        return value(valueIndex(expr));
    }
    int select_t::valueIndex(const expr_t& expr) const {
        int index = mFields.indexOf(expr);
        if (index > -1) {
            return index;
        }
        QVariant::Type type = expr.value().type();
        Q_ASSERT(expr.type() == expr_t::expr_leaf);
        Q_ASSERT(!expr.value().isNull());
        if (type == QVariant::Int) {
            return expr.value().toInt();
        } else if (type == QVariant::String) {
            QString name = expr.value().toString();
            Q_ASSERT(!name.isEmpty());
            for (index = 0; index < mFields.size(); index++) {
                if (mFields[index].type() == expr_t::expr_as) {
                    if (name == mFields[index].arg(1).value().toString()) {
                        return index;
                    }
                }
            }
        }
        Q_ASSERT(0);

        return -1;
    }
    bool select_t::next() {
        return mQuery.next();
    }
    select_t& select_t::next(bool* ok) {
        if (*ok) {
            *ok = next();
        }
        return *this;
    }
    bool select_t::exec() {
        return query_t::exec();
    }
    select_t& select_t::exec(bool* ok) {
        if (*ok) {
            *ok = exec();
        }
        return *this;
    }
    QString select_t::joinExpr() const {
        if (mTables.size() < 2) {
            return QString();
        }
        QStringList joins;
        for (int i = 1; i < mTables.size(); i++) {
            joins << mJoinExprs[i].toString(mTables[i], mDatabase.driver());
        }
        return joins.join(" ");
    }
    QString select_t::fromExpr() const {
        if (mTables.isEmpty()) {
            return QString();
        }
        return QString("FROM %1").arg(mTables[0].toString());
    }
    QString select_t::toString(const QString& prefix, const exprlist_t& exprs) const {
        if (exprs.isEmpty()) {
            return QString();
        }
        return QString("%1 %2").arg(prefix).arg(exprs.toString(mDatabase.driver()));
    }
    QString select_t::toString(const QString& prefix, const expr_t& expr) const {
        if (expr.isNull()) {
            return QString();
        }
        return QString("%1 %2").arg(prefix).arg(expr.toString(mDatabase.driver()));
    }
    QString select_t::toString() const {
        return joinNotEmpty({"SELECT", mFields.toString(mDatabase.driver()), fromExpr(), joinExpr(),
                             toString("WHERE", mWhere), toString("GROUP BY", mGroupBy),
                             toString("HAVING", mHaving), toString("ORDER BY", mOrderBy),
                             mLimit.toString()},
                            " ");
    }
    select_t& select_t::from(const table_t& table) {
        return innerJoin(table).on(expr_t());
    }
    select_t& select_t::from(const table_t& table, const alias_t& alias) {
        return leftJoin(table, alias).on(expr_t());
    }
    select_t& select_t::join(joinexpr_t::join_type type, const aliasedtable_t& table) {
        mJoinType = type;
        mTables.append(table);
        return *this;
    }
    select_t& select_t::leftJoin(const table_t& table) {
        return join(joinexpr_t::join_left, aliasedtable_t(table));
    }
    select_t& select_t::leftJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_left, aliasedtable_t(table, alias));
    }
    select_t& select_t::rightJoin(const table_t& table) {
        return join(joinexpr_t::join_right, aliasedtable_t(table));
    }
    select_t& select_t::rightJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_right, aliasedtable_t(table, alias));
    }
    select_t& select_t::innerJoin(const table_t& table) {
        return join(joinexpr_t::join_inner, aliasedtable_t(table));
    }
    select_t& select_t::innerJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_inner, aliasedtable_t(table, alias));
    }
    select_t& select_t::on(const expr_t& expr) {
        mJoinExprs.append(joinexpr_t(mJoinType, expr));
        return *this;
    }
    select_t& select_t::on(const field_t& f1, const field_t& f2) {
        return on(equal(f1, f2));
    }
    select_t& select_t::where(const expr_t& cond) {
        mWhere = cond;
        return *this;
    }
    select_t& select_t::having(const expr_t& cond) {
        mHaving = cond;
        return *this;
    }
    select_t& select_t::orderBy(const exprlist_t& order) {
        mOrderBy = order;
        return *this;
    }
    select_t& select_t::groupBy(const exprlist_t& fields) {
        mGroupBy = fields;
        return *this;
    }
    select_t& select_t::limit(int count) {
        mLimit = limit_t(count);
        return *this;
    }
    select_t& select_t::limit(int offset, int count) {
        mLimit = limit_t(offset, count);
        return *this;
    }
    select_t select(const exprlist_t& fields) {
        return select_t(fields);
    }
    select_t select(const QSqlDatabase& database, const exprlist_t& fields) {
        return select_t(database, fields);
    }

    insert_t::insert_t() : mTable(0) {
    }
    insert_t::insert_t(const QSqlDatabase& database) : query_t(database), mTable(0) {
    }
    insert_t& insert_t::into(const table_t& table, const exprlist_t& fields) {
        mTable = &table;
        mFields = fields;
        return *this;
    }
    insert_t& insert_t::values(const exprlist_t& values) {
        mValues = values;
        return *this;
    }
    bool insert_t::exec() {
        return query_t::exec();
    }
    insert_t& insert_t::exec(bool* ok) {
        if (*ok) {
            *ok = exec();
        }
        return *this;
    }
    QVariant insert_t::lastInsertId() const {
        return mQuery.lastInsertId();
    }
    QString insert_t::fieldsToString() const {
        QStringList res;
        foreach (const expr_t& expr, mFields) { res << expr.field()->name(); }
        return res.join(", ");
    }
    QString insert_t::toString() const {

        Q_ASSERT(mTable != 0);
        Q_ASSERT(!mFields.isEmpty());
        Q_ASSERT(!mValues.isEmpty());
        Q_ASSERT(!mFields.isEmpty());
        Q_ASSERT(mFields.size() == mValues.size());

        QSqlDriver* driver = mDatabase.driver();
        return joinNotEmpty({"INSERT INTO", mTable->tableName() + inParenthesis(fieldsToString()),
                             "VALUES", inParenthesis(mValues.toString(driver))},
                            " ");
    }
    insert_t insert() {
        return insert_t();
    }
    insert_t insert(const QSqlDatabase& database) {
        return insert_t(database);
    }

    update_t::update_t() : mTable(0) {
    }
    update_t::update_t(const table_t& table) : mTable(&table) {
    }
    update_t::update_t(const QSqlDatabase& database, const table_t& table)
        : query_t(database), mTable(&table) {
    }
    update_t& update_t::set(const exprlist_t& nameValues) {
        mNameValues = nameValues;
        return *this;
    }
    update_t& update_t::where(const expr_t& expr) {
        mWhere = expr;
        return *this;
    }
    QString update_t::toString() const {

        if (mTable == 0 || mWhere.isNull() || mNameValues.isEmpty()) {
            return QString();
        }
        bool fullname = mDatabase.driverName() != DRIVER_SQLITE;
        expr_t name;
        QStringList res;
        QSqlDriver* driver = mDatabase.driver();
        foreach (const expr_t& item, mNameValues) {
            if (name.isNull()) {
                name = item;
                if (name.field() == 0) {
                    return QString();
                }
            } else {
                res << QString("%1 = %2")
                           .arg(name.field()->name())
                           .arg(item.toString(driver, fullname));
                name = expr_t();
            }
        }
        if (!name.isNull()) {
            return QString();
        }
        return joinNotEmpty({"UPDATE", mTable->tableName(), "SET", res.join(", "), "WHERE",
                             mWhere.toString(driver, fullname)},
                            " ");
    }
    bool update_t::exec() {
        return query_t::exec();
    }
    update_t& update_t::exec(bool* ok) {
        if (*ok) {
            *ok = exec();
        }
        return *this;
    }
    update_t update_(const table_t& table) {
        return update_t(table);
    }
    update_t update_(const QSqlDatabase& database, const table_t& table) {
        return update_t(database, table);
    }

    delete_t::delete_t() : mTable(0) {
    }
    delete_t::delete_t(const QSqlDatabase& database) : query_t(database), mTable(0) {
    }
    delete_t& delete_t::from(const table_t& table) {
        mTable = &table;
        return *this;
    }
    delete_t& delete_t::where(const expr_t& expr) {
        mWhere = expr;
        return *this;
    }
    QString delete_t::toString() const {
        QSqlDriver* d = mDatabase.driver();
        if (mTable == 0 || mWhere.isNull()) {
            return QString();
        }
        return joinNotEmpty({"DELETE FROM", mTable->tableName(), "WHERE", mWhere.toString(d)}, " ");
    }
    bool delete_t::exec() {
        return query_t::exec();
    }
    delete_t& delete_t::exec(bool* ok) {
        if (*ok) {
            *ok = exec();
        }
        return *this;
    }
    delete_t delete_() {
        return delete_t();
    }
    delete_t delete_(const QSqlDatabase& database) {
        return delete_t(database);
    }

    namespace util {

        QList<int> toIntList(select_t& query, const expr_t& key) {
            QList<int> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex).toInt();
            }
            return res;
        }
        QMap<int, int> toIntIntMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<int, int> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex).toInt();
            }
            return res;
        }
        QMap<int, QString> toIntStringMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<int, QString> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex).toString();
            }
            return res;
        }
        QMap<int, QVariant> toIntVariantMap(select_t& query, const expr_t& key,
                                            const expr_t& value) {
            QMap<int, QVariant> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex);
            }
            return res;
        }
        QMap<int, QDate> toIntDateMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<int, QDate> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex).toDate();
            }
            return res;
        }
        QMap<int, QDateTime> toIntDateTimeMap(select_t& query, const expr_t& key,
                                              const expr_t& value) {
            QMap<int, QDateTime> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex).toDateTime();
            }
            return res;
        }
        QMap<int, bool> toIntBoolMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<int, bool> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toInt()] = query.value(valueIndex).toBool();
            }
            return res;
        }
        QList<QString> toStringList(select_t& query, const expr_t& key) {
            QList<QString> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex).toString();
            }
            return res;
        }
        QMap<QString, int> toStringIntMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<QString, int> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex).toInt();
            }
            return res;
        }
        QMap<QString, QString> toStringStringMap(select_t& query, const expr_t& key,
                                                 const expr_t& value) {
            QMap<QString, QString> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex).toString();
            }
            return res;
        }
        QMap<QString, QVariant> toStringVariantMap(select_t& query, const expr_t& key,
                                                   const expr_t& value) {
            QMap<QString, QVariant> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex);
            }
            return res;
        }
        QMap<QString, QDate> toStringDateMap(select_t& query, const expr_t& key,
                                             const expr_t& value) {
            QMap<QString, QDate> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex).toDate();
            }
            return res;
        }
        QMap<QString, QDateTime> toStringDateTimeMap(select_t& query, const expr_t& key,
                                                     const expr_t& value) {
            QMap<QString, QDateTime> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex).toDateTime();
            }
            return res;
        }
        QMap<QString, bool> toStringBoolMap(select_t& query, const expr_t& key,
                                            const expr_t& value) {
            QMap<QString, bool> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toString()] = query.value(valueIndex).toBool();
            }
            return res;
        }
        QList<QVariant> toVariantList(select_t& query, const expr_t& key) {
            QList<QVariant> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex);
            }
            return res;
        }
        QList<QDate> toDateList(select_t& query, const expr_t& key) {
            QList<QDate> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex).toDate();
            }
            return res;
        }
        QMap<QDate, int> toDateIntMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<QDate, int> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex).toInt();
            }
            return res;
        }
        QMap<QDate, QString> toDateStringMap(select_t& query, const expr_t& key,
                                             const expr_t& value) {
            QMap<QDate, QString> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex).toString();
            }
            return res;
        }
        QMap<QDate, QVariant> toDateVariantMap(select_t& query, const expr_t& key,
                                               const expr_t& value) {
            QMap<QDate, QVariant> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex);
            }
            return res;
        }
        QMap<QDate, QDate> toDateDateMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<QDate, QDate> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex).toDate();
            }
            return res;
        }
        QMap<QDate, QDateTime> toDateDateTimeMap(select_t& query, const expr_t& key,
                                                 const expr_t& value) {
            QMap<QDate, QDateTime> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex).toDateTime();
            }
            return res;
        }
        QMap<QDate, bool> toDateBoolMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<QDate, bool> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDate()] = query.value(valueIndex).toBool();
            }
            return res;
        }
        QList<QDateTime> toDateTimeList(select_t& query, const expr_t& key) {
            QList<QDateTime> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex).toDateTime();
            }
            return res;
        }
        QMap<QDateTime, int> toDateTimeIntMap(select_t& query, const expr_t& key,
                                              const expr_t& value) {
            QMap<QDateTime, int> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex).toInt();
            }
            return res;
        }
        QMap<QDateTime, QString> toDateTimeStringMap(select_t& query, const expr_t& key,
                                                     const expr_t& value) {
            QMap<QDateTime, QString> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex).toString();
            }
            return res;
        }
        QMap<QDateTime, QVariant> toDateTimeVariantMap(select_t& query, const expr_t& key,
                                                       const expr_t& value) {
            QMap<QDateTime, QVariant> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex);
            }
            return res;
        }
        QMap<QDateTime, QDate> toDateTimeDateMap(select_t& query, const expr_t& key,
                                                 const expr_t& value) {
            QMap<QDateTime, QDate> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex).toDate();
            }
            return res;
        }
        QMap<QDateTime, QDateTime> toDateTimeDateTimeMap(select_t& query, const expr_t& key,
                                                         const expr_t& value) {
            QMap<QDateTime, QDateTime> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex).toDateTime();
            }
            return res;
        }
        QMap<QDateTime, bool> toDateTimeBoolMap(select_t& query, const expr_t& key,
                                                const expr_t& value) {
            QMap<QDateTime, bool> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toDateTime()] = query.value(valueIndex).toBool();
            }
            return res;
        }
        QList<bool> toBoolList(select_t& query, const expr_t& key) {
            QList<bool> res;
            int keyIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                }
                res << query.value(keyIndex).toBool();
            }
            return res;
        }
        QMap<bool, int> toBoolIntMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<bool, int> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex).toInt();
            }
            return res;
        }
        QMap<bool, QString> toBoolStringMap(select_t& query, const expr_t& key,
                                            const expr_t& value) {
            QMap<bool, QString> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex).toString();
            }
            return res;
        }
        QMap<bool, QVariant> toBoolVariantMap(select_t& query, const expr_t& key,
                                              const expr_t& value) {
            QMap<bool, QVariant> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex);
            }
            return res;
        }
        QMap<bool, QDate> toBoolDateMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<bool, QDate> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex).toDate();
            }
            return res;
        }
        QMap<bool, QDateTime> toBoolDateTimeMap(select_t& query, const expr_t& key,
                                                const expr_t& value) {
            QMap<bool, QDateTime> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex).toDateTime();
            }
            return res;
        }
        QMap<bool, bool> toBoolBoolMap(select_t& query, const expr_t& key, const expr_t& value) {
            QMap<bool, bool> res;
            int keyIndex = -1;
            int valueIndex = -1;
            while (query.next()) {
                if (keyIndex < 0) {
                    keyIndex = query.valueIndex(key);
                    valueIndex = query.valueIndex(value);
                }
                res[query.value(keyIndex).toBool()] = query.value(valueIndex).toBool();
            }
            return res;
        }
    } // namespace util

    QString field_database_date_t::name() const {
        return "date";
    }
    QString field_database_date_t::fullName() const {
        return "database.date";
    }
    QString field_database_date_t::aliasName() const {
        return "database.date";
    }

    QString field_database_connectionName_t::name() const {
        return "connectionName";
    }
    QString field_database_connectionName_t::fullName() const {
        return "database.connectionName";
    }
    QString field_database_connectionName_t::aliasName() const {
        return "database.connectionName";
    }

    QString field_database_driver_t::name() const {
        return "driver";
    }
    QString field_database_driver_t::fullName() const {
        return "database.driver";
    }
    QString field_database_driver_t::aliasName() const {
        return "database.driver";
    }

    QString field_database_host_t::name() const {
        return "host";
    }
    QString field_database_host_t::fullName() const {
        return "database.host";
    }
    QString field_database_host_t::aliasName() const {
        return "database.host";
    }

    QString field_database_user_t::name() const {
        return "user";
    }
    QString field_database_user_t::fullName() const {
        return "database.user";
    }
    QString field_database_user_t::aliasName() const {
        return "database.user";
    }

    QString field_database_password_t::name() const {
        return "password";
    }
    QString field_database_password_t::fullName() const {
        return "database.password";
    }
    QString field_database_password_t::aliasName() const {
        return "database.password";
    }

    QString field_database_database_t::name() const {
        return "database";
    }
    QString field_database_database_t::fullName() const {
        return "database.database";
    }
    QString field_database_database_t::aliasName() const {
        return "database.database";
    }

    QString field_database_port_t::name() const {
        return "port";
    }
    QString field_database_port_t::fullName() const {
        return "database.port";
    }
    QString field_database_port_t::aliasName() const {
        return "database.port";
    }

    table_database_t::table_database_t()
        : _all({&date, &connectionName, &driver, &host, &user, &password, &database, &port}) {
    }
    QString table_database_t::tableName() const {
        return "database";
    }
    QString table_database_t::aliasName() const {
        return "database";
    }
    table_database_t database = table_database_t();

    QString field_query_date_t::name() const {
        return "date";
    }
    QString field_query_date_t::fullName() const {
        return "query.date";
    }
    QString field_query_date_t::aliasName() const {
        return "query.date";
    }

    QString field_query_connectionName_t::name() const {
        return "connectionName";
    }
    QString field_query_connectionName_t::fullName() const {
        return "query.connectionName";
    }
    QString field_query_connectionName_t::aliasName() const {
        return "query.connectionName";
    }

    QString field_query_query_t::name() const {
        return "query";
    }
    QString field_query_query_t::fullName() const {
        return "query.query";
    }
    QString field_query_query_t::aliasName() const {
        return "query.query";
    }

    table_query_t::table_query_t() : _all({&date, &connectionName, &query}) {
    }
    QString table_query_t::tableName() const {
        return "query";
    }
    QString table_query_t::aliasName() const {
        return "query";
    }
    table_query_t query = table_query_t();

    QString field_relations_name_t::name() const {
        return "name";
    }
    QString field_relations_name_t::fullName() const {
        return "relations.name";
    }
    QString field_relations_name_t::aliasName() const {
        return "relations.name";
    }

    QString field_relations_value_t::name() const {
        return "value";
    }
    QString field_relations_value_t::fullName() const {
        return "relations.value";
    }
    QString field_relations_value_t::aliasName() const {
        return "relations.value";
    }

    table_relations_t::table_relations_t() : _all({&name, &value}) {
    }
    QString table_relations_t::tableName() const {
        return "relations";
    }
    QString table_relations_t::aliasName() const {
        return "relations";
    }
    table_relations_t relations = table_relations_t();

} // namespace mugisql
