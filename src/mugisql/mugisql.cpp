// DO NOT EDIT ** This file was generated by mugicpp ** DO NOT EDIT
#include "mugisql.h"
namespace mugisql {

    QString inParenthesis(const QString& expr, bool yes) {
        return yes ? ("(" + expr + ")") : expr;
    }
    QString spaced(const QString& expr, bool yes) {
        return yes ? (" " + expr + " ") : expr;
    }

    fieldlist_t::fieldlist_t() {
    }
    fieldlist_t::fieldlist_t(const field_t& field) {
        this->append(&field);
    }
    fieldlist_t::fieldlist_t(const std::initializer_list<const field_t*>& values)
        : QList<const field_t*>(values) {
    }
    QString fieldlist_t::toString(bool full) const {
        QStringList res;
        foreach (const field_t* field, *this) { res << (full ? field->fullName() : field->name()); }
        return res.join(", ");
    }

    aliasedtable_t::aliasedtable_t() : mTable(0), mAlias(0) {
    }
    aliasedtable_t::aliasedtable_t(const table_t& table, const alias_t& alias)
        : mTable(&table), mAlias(&alias) {
    }
    aliasedtable_t::aliasedtable_t(const table_t& table) : mTable(&table), mAlias(0) {
    }
    const table_t* aliasedtable_t::table() const {
        return mTable;
    }
    void aliasedtable_t::setTable(const table_t* value) {
        mTable = value;
    }
    const alias_t* aliasedtable_t::alias() const {
        return mAlias;
    }
    void aliasedtable_t::setAlias(const alias_t* value) {
        mAlias = value;
    }
    QString aliasedtable_t::toString() const {
        if (!mTable) {
            return QString();
        }
        if (mAlias) {
            return QString("%1 %2").arg(mAlias->tableName()).arg(mAlias->aliasName());
        }
        return mTable->aliasName();
    }

    arg_t::arg_t() : mField(0) {
    }
    arg_t::arg_t(const field_t& field) : mField(&field) {
    }
    arg_t::arg_t(const QVariant& value) : mValue(value), mField(0) {
    }
    arg_t::~arg_t() {
    }
    QString arg_t::toString(QSqlDriver* driver) const {
        if (!mField) {
            QSqlField field(QString(), mValue.type());
            field.setValue(mValue);
            return driver->formatValue(field);
        }
        return mField->aliasName();
    }
    const field_t* arg_t::field() const {
        return mField;
    }
    QVariant arg_t::value() const {
        return mValue;
    }

    expr_t::expr_t() : mType(expr_null) {
    }
    expr_t::expr_t(const field_t& field) : arg_t(field), mType(expr_leaf) {
    }
    expr_t::expr_t(int value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(const QString& value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(const char* value) : arg_t(QString(value)), mType(expr_leaf) {
    }
    expr_t::expr_t(const QVariant& value) : arg_t(value), mType(expr_leaf) {
    }
    expr_t::expr_t(expr_type type, const QList<expr_t>& args) : mType(type), mArgs(args) {
    }
    bool expr_t::isNull() const {
        return mType == expr_null;
    }
    expr_t::expr_type expr_t::type() const {
        return mType;
    }
    QList<expr_t> expr_t::args() const {
        return mArgs;
    }
    QString expr_t::infix(QSqlDriver* driver, const QString& name) const {
        return joinArgs(driver, true, spaced(name));
    }
    QString expr_t::func(QSqlDriver* driver, const QString& name) const {
        return name + inParenthesis(joinArgs(driver, false, ", "));
    }
    QString expr_t::prefix(QSqlDriver* driver, const QString& name) const {
        return name + " " + joinArgs(driver, true, ", ");
    }
    QString expr_t::suffix(QSqlDriver* driver, const QString& name) const {
        return joinArgs(driver, true, ", ") + " " + name;
    }
    QString expr_t::toString(QSqlDriver* driver) const {
        static QMap<expr_type, QString> infixmap = {{expr_equal, "="},
                                                    {expr_not_equal, "<>"},
                                                    {expr_less, "<"},
                                                    {expr_more, ">"},
                                                    {expr_less_or_equal, "<="},
                                                    {expr_more_or_equal, ">="},
                                                    {expr_or_, "OR"},
                                                    {expr_and_, "AND"},
                                                    {expr_add, "+"},
                                                    {expr_sub, "-"},
                                                    {expr_mul, "*"},
                                                    {expr_div, "/"},
                                                    {expr_sqlite_mod, "%"}};
        static QMap<expr_type, QString> prefixmap = {{expr_not_, "NOT"}};
        static QMap<expr_type, QString> funcmap = {{expr_abs, "ABS"},
                                                   {expr_sum, "SUM"},
                                                   {expr_avg, "AVG"},
                                                   {expr_min, "MIN"},
                                                   {expr_max, "MAX"},
                                                   {expr_round, "ROUND"},
                                                   {expr_sqlite_datetime, "DATETIME"},
                                                   {expr_mysql_sign, "SIGN"},
                                                   {expr_mysql_floor, "FLOOR"},
                                                   {expr_mysql_ceil, "CEIL"},
                                                   {expr_mysql_sqrt, "SQRT"},
                                                   {expr_mysql_asin, "ASIN"},
                                                   {expr_mysql_acos, "ACOS"},
                                                   {expr_mysql_atan, "ATAN"},
                                                   {expr_mysql_sin, "SIN"},
                                                   {expr_mysql_cos, "COS"},
                                                   {expr_mysql_tan, "TAN"},
                                                   {expr_mysql_mod, "MOD"},
                                                   {expr_mysql_power, "POWER"}};
        if (mType == expr_leaf) {
            return arg_t::toString(driver);
        } else if (mType == expr_desc) {
            return suffix(driver, "desc");
        } else if (mType == expr_asc) {
            return mArgs[0].toString(driver);
        } else if (infixmap.contains(mType)) {
            return infix(driver, infixmap[mType]);
        } else if (prefixmap.contains(mType)) {
            return prefix(driver, prefixmap[mType]);
        } else if (funcmap.contains(mType)) {
            return func(driver, funcmap[mType]);
        }
        return QString();
    }
    QString expr_t::joinArgs(QSqlDriver* driver, bool parenthesis, const QString& glue) const {
        QStringList args;
        static QSet<expr_type> needParenthesis = {
            expr_equal,         expr_not_equal, expr_less,      expr_more, expr_less_or_equal,
            expr_more_or_equal, expr_or_,       expr_and_,      expr_add,  expr_sub,
            expr_mul,           expr_div,       expr_sqlite_mod};
        foreach (const expr_t& arg, mArgs) {
            args << inParenthesis(arg.toString(driver),
                                  parenthesis && needParenthesis.contains(arg.type()));
        }
        return args.join(glue);
    }
    bool operator==(const expr_t& expr1, const expr_t& expr2) {
        return expr1.type() == expr2.type() && expr1.args() == expr2.args() &&
               expr1.value() == expr2.value() && expr1.field() == expr2.field();
    }

    exprlist_t::exprlist_t() {
    }
    exprlist_t::exprlist_t(const fieldlist_t& fields) {
        foreach (const field_t* field, fields) { append(*field); }
    }
    exprlist_t::exprlist_t(const QList<const field_t*>& fields) {
        foreach (const field_t* field, fields) { append(*field); }
    }
    exprlist_t::exprlist_t(const field_t& field) {
        append(field);
    }
    exprlist_t::exprlist_t(const expr_t& expr) {
        append(expr);
    }
    exprlist_t::exprlist_t(const std::initializer_list<expr_t>& values) : QList<expr_t>(values) {
    }
    QString exprlist_t::toString(QSqlDriver* driver) const {
        QStringList result;
        foreach (const expr_t& expr, *this) { result << expr.toString(driver); }
        return result.join(", ");
    }
    exprlist_t operator+(const exprlist_t& arg1, const exprlist_t& arg2) {
        exprlist_t res;
        res.append(arg1);
        res.append(arg2);
        return res;
    }
    exprlist_t operator+(const exprlist_t& arg1, const QVariant& arg2) {
        return arg1 + exprlist_t(expr_t(arg2));
    }
    exprlist_t operator+(const QVariant& arg1, const exprlist_t& arg2) {
        return exprlist_t(expr_t(arg1)) + arg2;
    }

    joinexpr_t::joinexpr_t() : mType(join_inner) {
    }
    joinexpr_t::joinexpr_t(join_type type, const expr_t& expr) : mExpr(expr), mType(type) {
    }
    expr_t joinexpr_t::expr() const {
        return mExpr;
    }
    joinexpr_t::join_type joinexpr_t::type() const {
        return mType;
    }
    QString joinexpr_t::toString(const aliasedtable_t& table, QSqlDriver* driver) const {
        static QStringList joins = {"INNER JOIN", "LEFT JOIN", "RIGHT JOIN"};
        return QString("%1 %2 ON %3")
            .arg(joins[mType])
            .arg(table.toString())
            .arg(mExpr.toString(driver));
    }

    limit_t::limit_t() : mOffset(0), mCount(0) {
    }
    limit_t::limit_t(int offset, int count) : mOffset(offset), mCount(count) {
    }
    limit_t::limit_t(int count) : mOffset(0), mCount(count) {
    }
    int limit_t::offset() const {
        return mOffset;
    }
    void limit_t::setOffset(int value) {
        mOffset = value;
    }
    int limit_t::count() const {
        return mCount;
    }
    void limit_t::setCount(int value) {
        mCount = value;
    }
    QString limit_t::toString() const {
        if (mCount == 0) {
            return QString();
        }
        if (mOffset == 0) {
            return QString("LIMIT %1").arg(mCount);
        }
        return QString("LIMIT %1, %2").arg(mOffset).arg(mCount);
    }

    expr_t desc(const expr_t& arg) {
        return expr_t(expr_t::expr_desc, {arg});
    }
    expr_t asc(const expr_t& arg) {
        return expr_t(expr_t::expr_asc, {arg});
    }
    expr_t equal(const exprlist_t& args) {
        return expr_t(expr_t::expr_equal, args);
    }
    expr_t equal(const expr_t& arg0, const expr_t& arg1) {
        return equal({arg0, arg1});
    }
    expr_t notEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_not_equal, args);
    }
    expr_t notEqual(const expr_t& arg0, const expr_t& arg1) {
        return notEqual({arg0, arg1});
    }
    expr_t less(const exprlist_t& args) {
        return expr_t(expr_t::expr_less, args);
    }
    expr_t less(const expr_t& arg0, const expr_t& arg1) {
        return less({arg0, arg1});
    }
    expr_t more(const exprlist_t& args) {
        return expr_t(expr_t::expr_more, args);
    }
    expr_t more(const expr_t& arg0, const expr_t& arg1) {
        return more({arg0, arg1});
    }
    expr_t lessOrEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_less_or_equal, args);
    }
    expr_t lessOrEqual(const expr_t& arg0, const expr_t& arg1) {
        return lessOrEqual({arg0, arg1});
    }
    expr_t moreOrEqual(const exprlist_t& args) {
        return expr_t(expr_t::expr_more_or_equal, args);
    }
    expr_t moreOrEqual(const expr_t& arg0, const expr_t& arg1) {
        return moreOrEqual({arg0, arg1});
    }
    expr_t or_(const exprlist_t& args) {
        return expr_t(expr_t::expr_or_, args);
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1) {
        return or_({arg0, arg1});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return or_({arg0, arg1, arg2});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return or_({arg0, arg1, arg2, arg3});
    }
    expr_t or_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return or_({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t and_(const exprlist_t& args) {
        return expr_t(expr_t::expr_and_, args);
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1) {
        return and_({arg0, arg1});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return and_({arg0, arg1, arg2});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return and_({arg0, arg1, arg2, arg3});
    }
    expr_t and_(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
                const expr_t& arg4) {
        return and_({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t add(const exprlist_t& args) {
        return expr_t(expr_t::expr_add, args);
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1) {
        return add({arg0, arg1});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return add({arg0, arg1, arg2});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return add({arg0, arg1, arg2, arg3});
    }
    expr_t add(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return add({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t sub(const exprlist_t& args) {
        return expr_t(expr_t::expr_sub, args);
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1) {
        return sub({arg0, arg1});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return sub({arg0, arg1, arg2});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return sub({arg0, arg1, arg2, arg3});
    }
    expr_t sub(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return sub({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t mul(const exprlist_t& args) {
        return expr_t(expr_t::expr_mul, args);
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1) {
        return mul({arg0, arg1});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return mul({arg0, arg1, arg2});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return mul({arg0, arg1, arg2, arg3});
    }
    expr_t mul(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return mul({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t div(const exprlist_t& args) {
        return expr_t(expr_t::expr_div, args);
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1) {
        return div({arg0, arg1});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2) {
        return div({arg0, arg1, arg2});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3) {
        return div({arg0, arg1, arg2, arg3});
    }
    expr_t div(const expr_t& arg0, const expr_t& arg1, const expr_t& arg2, const expr_t& arg3,
               const expr_t& arg4) {
        return div({arg0, arg1, arg2, arg3, arg4});
    }
    expr_t not_(const expr_t& arg) {
        return expr_t(expr_t::expr_not_, {arg});
    }
    expr_t abs(const expr_t& arg) {
        return expr_t(expr_t::expr_abs, {arg});
    }
    expr_t sum(const expr_t& arg) {
        return expr_t(expr_t::expr_sum, {arg});
    }
    expr_t avg(const expr_t& arg) {
        return expr_t(expr_t::expr_avg, {arg});
    }
    expr_t min(const expr_t& arg) {
        return expr_t(expr_t::expr_min, {arg});
    }
    expr_t max(const expr_t& arg) {
        return expr_t(expr_t::expr_max, {arg});
    }
    expr_t round(const expr_t& arg) {
        return expr_t(expr_t::expr_round, {arg});
    }

    namespace sqlite {

        expr_t mod(const exprlist_t& args) {
            return expr_t(expr_t::expr_sqlite_mod, args);
        }
        expr_t mod(const expr_t& arg0, const expr_t& arg1) {
            return mod({arg0, arg1});
        }
        expr_t datetime(const exprlist_t& args) {
            return expr_t(expr_t::expr_sqlite_datetime, args);
        }
        expr_t datetime(const expr_t& arg0, const expr_t& arg1) {
            return datetime({arg0, arg1});
        }
    } // namespace sqlite

    namespace mysql {

        expr_t sign(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sign, {arg});
        }
        expr_t floor(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_floor, {arg});
        }
        expr_t ceil(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_ceil, {arg});
        }
        expr_t sqrt(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sqrt, {arg});
        }
        expr_t asin(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_asin, {arg});
        }
        expr_t acos(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_acos, {arg});
        }
        expr_t atan(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_atan, {arg});
        }
        expr_t sin(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_sin, {arg});
        }
        expr_t cos(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_cos, {arg});
        }
        expr_t tan(const expr_t& arg) {
            return expr_t(expr_t::expr_mysql_tan, {arg});
        }
        expr_t mod(const exprlist_t& args) {
            return expr_t(expr_t::expr_mysql_mod, args);
        }
        expr_t mod(const expr_t& arg0, const expr_t& arg1) {
            return mod({arg0, arg1});
        }
        expr_t power(const exprlist_t& args) {
            return expr_t(expr_t::expr_mysql_power, args);
        }
        expr_t power(const expr_t& arg0, const expr_t& arg1) {
            return power({arg0, arg1});
        }
    } // namespace mysql

    query_t::query_t() : mDatabase(QSqlDatabase::database()) {
    }
    query_t::query_t(const QSqlDatabase& database) : mDatabase(database) {
    }
    bool query_t::exec() {
        mQuery = QSqlQuery(mDatabase);
        QString expr = toString();
        return mQuery.exec(expr);
    }
    QString query_t::joinNotEmpty(const QStringList& values, const QString& glue) {
        QStringList result;
        foreach (const QString& value, values) {
            if (!value.isEmpty()) {
                result << value;
            }
        }
        return result.join(glue);
    }
    QSqlError query_t::lastError() const {
        return mQuery.lastError();
    }

    select_t::select_t(const exprlist_t& fields)
        : mFields(fields), mJoinType(joinexpr_t::join_inner) {
    }
    select_t::select_t(const QSqlDatabase& database, const exprlist_t& fields)
        : query_t(database), mFields(fields), mJoinType(joinexpr_t::join_inner) {
    }
    QVariant select_t::value(int index) const {
        return mQuery.value(index);
    }
    QVariant select_t::value(const expr_t& expr) const {
        int index = mFields.indexOf(expr);
        Q_ASSERT(index > -1);
        return value(index);
    }
    bool select_t::next() {
        return mQuery.next();
    }
    QString select_t::joinExpr() const {
        if (mTables.size() < 2) {
            return QString();
        }
        QStringList joins;
        for (int i = 1; i < mTables.size(); i++) {
            joins << mJoinExprs[i].toString(mTables[i], mDatabase.driver());
        }
        return joins.join(" ");
    }
    QString select_t::fromExpr() const {
        if (mTables.isEmpty()) {
            return QString();
        }
        return QString("FROM %1").arg(mTables[0].toString());
    }
    QString select_t::toString(const QString& prefix, const exprlist_t& exprs) const {
        if (exprs.isEmpty()) {
            return QString();
        }
        return QString("%1 %2").arg(prefix).arg(exprs.toString(mDatabase.driver()));
    }
    QString select_t::toString(const QString& prefix, const expr_t& expr) const {
        if (expr.isNull()) {
            return QString();
        }
        return QString("%1 %2").arg(prefix).arg(expr.toString(mDatabase.driver()));
    }
    QString select_t::toString() const {
        return joinNotEmpty({"SELECT", mFields.toString(mDatabase.driver()), fromExpr(), joinExpr(),
                             toString("WHERE", mWhere), toString("GROUP BY", mGroupBy),
                             toString("HAVING", mHaving), toString("ORDER BY", mOrderBy),
                             mLimit.toString()},
                            " ");
    }
    select_t& select_t::from(const table_t& table) {
        return innerJoin(table).on(expr_t());
    }
    select_t& select_t::from(const table_t& table, const alias_t& alias) {
        return leftJoin(table, alias).on(expr_t());
    }
    select_t& select_t::join(joinexpr_t::join_type type, const aliasedtable_t& table) {
        mJoinType = type;
        mTables.append(table);
        return *this;
    }
    select_t& select_t::leftJoin(const table_t& table) {
        return join(joinexpr_t::join_left, aliasedtable_t(table));
    }
    select_t& select_t::leftJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_left, aliasedtable_t(table, alias));
    }
    select_t& select_t::rightJoin(const table_t& table) {
        return join(joinexpr_t::join_right, aliasedtable_t(table));
    }
    select_t& select_t::rightJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_right, aliasedtable_t(table, alias));
    }
    select_t& select_t::innerJoin(const table_t& table) {
        return join(joinexpr_t::join_inner, aliasedtable_t(table));
    }
    select_t& select_t::innerJoin(const table_t& table, const alias_t& alias) {
        return join(joinexpr_t::join_inner, aliasedtable_t(table, alias));
    }
    select_t& select_t::on(const expr_t& expr) {
        mJoinExprs.append(joinexpr_t(mJoinType, expr));
        return *this;
    }
    select_t& select_t::on(const field_t& f1, const field_t& f2) {
        return on(equal(f1, f2));
    }
    select_t& select_t::where(const expr_t& cond) {
        mWhere = cond;
        return *this;
    }
    select_t& select_t::having(const expr_t& cond) {
        mHaving = cond;
        return *this;
    }
    select_t& select_t::orderBy(const exprlist_t& order) {
        mOrderBy = order;
        return *this;
    }
    select_t& select_t::groupBy(const exprlist_t& fields) {
        mGroupBy = fields;
        return *this;
    }
    select_t& select_t::limit(int count) {
        mLimit = limit_t(count);
        return *this;
    }
    select_t& select_t::limit(int offset, int count) {
        mLimit = limit_t(offset, count);
        return *this;
    }
    select_t select(const exprlist_t& fields) {
        return select_t(fields);
    }
    select_t select(const QSqlDatabase& database, const exprlist_t& fields) {
        return select_t(database, fields);
    }

    insert_t::insert_t() : mTable(0) {
    }
    insert_t::insert_t(const QSqlDatabase& database) : query_t(database), mTable(0) {
    }
    insert_t& insert_t::into(const table_t& table, const exprlist_t& fields) {
        mTable = &table;
        mFields = fields;
        return *this;
    }
    insert_t& insert_t::values(const exprlist_t& values) {
        mValues = values;
        return *this;
    }
    insert_t& insert_t::values(const QVariantList& values) {
        exprlist_t res;
        foreach (const QVariant& value, values) { res.append(expr_t(value)); }
        mValues = res;
        return *this;
    }
    QVariant insert_t::lastInsertId() const {
        return mQuery.lastInsertId();
    }
    QString insert_t::fieldsToString() const {
        QStringList res;
        foreach (const expr_t& expr, mFields) { res << expr.field()->name(); }
        return res.join(", ");
    }
    QString insert_t::toString() const {

        Q_ASSERT(mTable != 0);
        Q_ASSERT(!mFields.isEmpty());
        Q_ASSERT(!mValues.isEmpty());
        Q_ASSERT(!mFields.isEmpty());
        Q_ASSERT(mFields.size() == mValues.size());

        QSqlDriver* d = mDatabase.driver();
        return joinNotEmpty({"INSERT INTO", mTable->tableName() + inParenthesis(fieldsToString()),
                             "VALUES", inParenthesis(mValues.toString(d))},
                            " ");
    }
    insert_t insert() {
        return insert_t();
    }
    insert_t insert(const QSqlDatabase& database) {
        return insert_t(database);
    }

    update_t::update_t() : mTable(0) {
    }
    update_t::update_t(const table_t& table) : mTable(&table) {
    }
    update_t::update_t(const QSqlDatabase& database, const table_t& table)
        : query_t(database), mTable(&table) {
    }
    update_t& update_t::set(const exprlist_t& nameValues) {
        mNameValues = nameValues;
        return *this;
    }
    update_t& update_t::where(const expr_t& expr) {
        mWhere = expr;
        return *this;
    }
    QString update_t::toString() const {

        if (mTable == 0 || mWhere.isNull() || mNameValues.isEmpty()) {
            return QString();
        }
        expr_t name;
        QStringList res;
        QSqlDriver* d = mDatabase.driver();
        foreach (const expr_t& item, mNameValues) {
            if (name.isNull()) {
                name = item;
                if (name.field() == 0) {
                    return QString();
                }
            } else {
                res << QString("%1 = %2").arg(name.toString(d)).arg(item.toString(d));
                name = expr_t();
            }
        }
        if (!name.isNull()) {
            return QString();
        }
        return joinNotEmpty(
            {"UPDATE", mTable->tableName(), "SET", res.join(", "), "WHERE", mWhere.toString(d)},
            " ");
    }
    update_t update(const table_t& table) {
        return update_t(table);
    }
    update_t update(const QSqlDatabase& database, const table_t& table) {
        return update_t(database, table);
    }

    delete_t::delete_t() : mTable(0) {
    }
    delete_t::delete_t(const QSqlDatabase& database) : query_t(database), mTable(0) {
    }
    delete_t& delete_t::from(const table_t& table) {
        mTable = &table;
        return *this;
    }
    delete_t& delete_t::where(const expr_t& expr) {
        mWhere = expr;
        return *this;
    }
    QString delete_t::toString() const {
        QSqlDriver* d = mDatabase.driver();
        if (mTable == 0 || mWhere.isNull()) {
            return QString();
        }
        return joinNotEmpty({"DELETE FROM", mTable->tableName(), "WHERE", mWhere.toString(d)}, " ");
    }
    delete_t delete_() {
        return delete_t();
    }
    delete_t delete_(const QSqlDatabase& database) {
        return delete_t(database);
    }

    QString field_database_date_t::name() const {
        return "date";
    }
    QString field_database_date_t::fullName() const {
        return "database.date";
    }
    QString field_database_date_t::aliasName() const {
        return "database.date";
    }

    QString field_database_connectionName_t::name() const {
        return "connectionName";
    }
    QString field_database_connectionName_t::fullName() const {
        return "database.connectionName";
    }
    QString field_database_connectionName_t::aliasName() const {
        return "database.connectionName";
    }

    QString field_database_driver_t::name() const {
        return "driver";
    }
    QString field_database_driver_t::fullName() const {
        return "database.driver";
    }
    QString field_database_driver_t::aliasName() const {
        return "database.driver";
    }

    QString field_database_host_t::name() const {
        return "host";
    }
    QString field_database_host_t::fullName() const {
        return "database.host";
    }
    QString field_database_host_t::aliasName() const {
        return "database.host";
    }

    QString field_database_user_t::name() const {
        return "user";
    }
    QString field_database_user_t::fullName() const {
        return "database.user";
    }
    QString field_database_user_t::aliasName() const {
        return "database.user";
    }

    QString field_database_password_t::name() const {
        return "password";
    }
    QString field_database_password_t::fullName() const {
        return "database.password";
    }
    QString field_database_password_t::aliasName() const {
        return "database.password";
    }

    QString field_database_database_t::name() const {
        return "database";
    }
    QString field_database_database_t::fullName() const {
        return "database.database";
    }
    QString field_database_database_t::aliasName() const {
        return "database.database";
    }

    QString field_database_port_t::name() const {
        return "port";
    }
    QString field_database_port_t::fullName() const {
        return "database.port";
    }
    QString field_database_port_t::aliasName() const {
        return "database.port";
    }

    table_database_t::table_database_t()
        : _all({&date, &connectionName, &driver, &host, &user, &password, &database, &port}) {
    }
    QString table_database_t::tableName() const {
        return "database";
    }
    QString table_database_t::aliasName() const {
        return "database";
    }
    table_database_t database = table_database_t();

    QString field_query_date_t::name() const {
        return "date";
    }
    QString field_query_date_t::fullName() const {
        return "query.date";
    }
    QString field_query_date_t::aliasName() const {
        return "query.date";
    }

    QString field_query_connectionName_t::name() const {
        return "connectionName";
    }
    QString field_query_connectionName_t::fullName() const {
        return "query.connectionName";
    }
    QString field_query_connectionName_t::aliasName() const {
        return "query.connectionName";
    }

    QString field_query_query_t::name() const {
        return "query";
    }
    QString field_query_query_t::fullName() const {
        return "query.query";
    }
    QString field_query_query_t::aliasName() const {
        return "query.query";
    }

    table_query_t::table_query_t() : _all({&date, &connectionName, &query}) {
    }
    QString table_query_t::tableName() const {
        return "query";
    }
    QString table_query_t::aliasName() const {
        return "query";
    }
    table_query_t query = table_query_t();

    QString field_relations_name_t::name() const {
        return "name";
    }
    QString field_relations_name_t::fullName() const {
        return "relations.name";
    }
    QString field_relations_name_t::aliasName() const {
        return "relations.name";
    }

    QString field_relations_value_t::name() const {
        return "value";
    }
    QString field_relations_value_t::fullName() const {
        return "relations.value";
    }
    QString field_relations_value_t::aliasName() const {
        return "relations.value";
    }

    table_relations_t::table_relations_t() : _all({&name, &value}) {
    }
    QString table_relations_t::tableName() const {
        return "relations";
    }
    QString table_relations_t::aliasName() const {
        return "relations";
    }
    table_relations_t relations = table_relations_t();

} // namespace mugisql
